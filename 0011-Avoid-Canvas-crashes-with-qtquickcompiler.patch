From 40a80ec9d712d8c40ebd6a6373322c3332ff5b50 Mon Sep 17 00:00:00 2001
From: Laszlo Agocs <laszlo.agocs@theqtcompany.com>
Date: Mon, 23 May 2016 16:01:44 +0200
Subject: [PATCH 11/40] Avoid Canvas crashes with qtquickcompiler

Change-Id: Ic87052308706b8ef71e2f27837abfbaea57c43cc
Task-number: QTBUG-49692
Reviewed-by: Mitch Curtis <mitch.curtis@qt.io>
---
 src/quick/items/context2d/qquickcanvasitem.cpp | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/quick/items/context2d/qquickcanvasitem.cpp b/src/quick/items/context2d/qquickcanvasitem.cpp
index 9fb49f9..47ac2c4 100644
--- a/src/quick/items/context2d/qquickcanvasitem.cpp
+++ b/src/quick/items/context2d/qquickcanvasitem.cpp
@@ -675,10 +675,14 @@ void QQuickCanvasItem::itemChange(QQuickItem::ItemChange change, const QQuickIte
     QSGRenderContext *context = QQuickWindowPrivate::get(d->window)->context;
 
     // Rendering to FramebufferObject needs a valid OpenGL context.
-    if (context != 0 && (d->renderTarget != FramebufferObject || context->isValid()))
-        sceneGraphInitialized();
-    else
+    if (context != 0 && (d->renderTarget != FramebufferObject || context->isValid())) {
+        // Defer the call. In some (arguably incorrect) cases we get here due
+        // to ItemSceneChange with the user-supplied property values not yet
+        // set. Work this around by a deferred invoke. (QTBUG-49692)
+        QMetaObject::invokeMethod(this, "sceneGraphInitialized", Qt::QueuedConnection);
+    } else {
         connect(d->window, SIGNAL(sceneGraphInitialized()), SLOT(sceneGraphInitialized()));
+    }
 }
 
 void QQuickCanvasItem::updatePolish()
-- 
1.9.3

